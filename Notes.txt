
Preliminary Steps:
1. Forked repository from main
2. Cloned repository to directory on my device.
3. Installed 'Rainbow CSV' extension b/c colors are neat

Currently: Able to take in list of file paths
Next Step:
For each file, get its filetype
  then call one of parse_xml(), parse_tsv(), parse_txt()
  all of them return List[JSON]
then merge sort each list. is it better to sort them individually first?
list is sorted by zipcode in ascending order --->
TODO:
1. implement parse_tsv
2. implement parse_txt
3. implement parse_xml
4. implement sorting thing
5. handle edge cases and specification details

Pretty printing::

    >>> import json
    >>> print(json.dumps({'4': 5, '6': 7}, sort_keys=True, indent=4))
    {
        "4": 5,
        "6": 7
    }

input3.tsv data:
first	middle	last	organization	address	city	state	county	zip	zip4
# also, if value in row is == 'N/A' then ignore/delete the value
# or if the middle name column = N/M/N ""
# some rows have the organization name in the last_name column and vice versa
# must check both. check if last_name is an organization by seeing if it contains
# LLC or Ltd or Inc. ?

[1] raw string literals and regular expressions (REs) https://docs.python.org/3.11/library/re.html
- A raw string treats the backslash character, '\', as a literal character, not an escape - helpful for parsing file paths.
- r'RE1|RE2|RE3|RE4' pattern contains 4 REs, separated by |
- - kinda works like the 'or' operator in boolean statements. also recall the syntax for 'or' in Java, ||
- [] indicates a set of characters; "characters can be listed individually"(python docs)
  try:
    pathnames = ast.literal_eval(input_str)
    if not isinstance(pathnames, list):
      raise ValueError
  except (SyntaxError, ValueError):
    # If parsing fails, split the string manually
    pattern = r'(?<=\.(?:xml|tsv|txt))(?=\s|$)(?!\w)'# (?=.)(?![$\w])'
    pathnames = re.split(pattern, input_str)
  
  # Strip extraneous characters
  pathnames = [p.strip("', []") for p in pathnames if p.strip()]
  return pathnames

import re
m = re.search('(?<=abc)def', 'abcdef')
m.group(0)
'def'

This example looks for a word following a hyphen:
m = re.search(r'(?<=-)\w+', 'spam-egg')
m.group(0)
'egg'
Changed in version 3.5: Added support for group references of fixed length.


Let's make a file with a single test case that we will expand upon later.
Here's the first: 


  David Scherrep
  12014 Cobblewood Lane North
  DUVAL COUNTY
  Jacksonville, Florida 32225